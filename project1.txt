Mark and Sweep Garbage Collector
Rob Hackman

This mark and sweep garbage collector employs fairly standard mark and sweep garbage collection techniques. 

For the free list I have chosen to go with a bitmapped freelist and the reason being is that I was struggling to get a free list to work properly in that I had a class freeobject that can still be seen in gc.h (I left it for this exact demonstration). I thought that with the assumption that all objects are at least the size of 2 descriptors pointers (since they must include their descriptor pointer and the size of the object itself can't be smaller than 1 descriptor pointer) that this object would work just fine for a free list, I would just store the next in the freelist in the dead object itself. This however seemed to cause issues in the BTGGGGC testcase I'm not sure why but it seemed to be overwriting data that was being used by the mutator. So I switched to a bitmapped free list where I had set areas for all free list information. This became much slower running the bench in 850ms instead of the 300ms I was getting with the freelist but it was the only way I could get BTGGGGC to not crash. However I did gain the advantage of instant coalescence.

For allocation strategies I only bother with the current pool and if I can't find something in the current pool I move on to the next pool. However I don't move to the next pool when I'm having lots of misses for free list because I don't have to check my freelist every time (and wouldn't want to because it's slow) because I store the minimum size we know at that time that the freelist for the given pool can't hold. I do this by having a variable in the pool currentFreeMax which is initialized to GGGGC_FREEMAX_INIT which is a 64-bit word with every bit on except the lowest order bit. This is basically a flag to let me know that this is a new pool that hasn't had sweep ran on it so don't bother checking the free list. When sweep is ran each pool gets this variable set to the GGGGC_MAX_WORD which is the 64-bit word with every bit on, since I could never store an object of this many words this is also a flag to say this pool has recently been swept so you should check it's freelist! Then everytime the freelist is checked and DOESN'T come up with a result this value is updated to the size we were looking for in the freelist (it's guaranteed to be smaller than the old one since we wouldn't look in the freelist if it wasn't!). After free list stuff is just simple bump-pointer allocation and allocating new pools when we can't find anything in the free list and there isn't enough space at the end of the pool.


